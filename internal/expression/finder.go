package expression

import "regexp"

type FoundExpression struct {
	Expression string
	StartPos   int
	EndPos     int
}

/*
выносим regex из функции так как

regexp.MustCompile:
1) Парсит шаблон, проверяет его на синтаксические ошибки.
2) Строит из него конечный автомат — специальную структуру данных, оптимизированную для поиска.

Эта операция относительно "дорогая". Она занимает процессорное время.

Если вы вызовете Finder 1000 раз, то 1000 раз будет
выполняться эта "дорогая" операция компиляции одного и того же шаблона. Это бессмысленная трата ресурсов.

ХОРОШО: Компиляция происходит только ОДИН РАЗ, когда программа запускается.
var candidateRegex = ... — это объявление глобальной (на уровне пакета) переменной.
Этот код выполнится один раз при инициализации пакета.
Всегда выносите regexp.MustCompile в глобальные переменные (на уровне пакета),
если шаблон известен заранее и не меняется.

[0-9\(] - любая цифра или (
[\d\s\.\+\-\*\/\(\)]* - 0 или более раз символы числа, пробела, скобок, умножения и деления и тд
[0-9\)] - любая цифра или )
*/
var condidateRegex = regexp.MustCompile(`[0-9\(][\d\s\.\+\-\*\/\(\)]*[0-9\)]`)

/*
прошлое выражение выцепляет не только выражения,
но и числа и здесь фильтруем, чтобы было выражение содержащие мат знаки
123 - не пройдет, 1 + 2 продет есть +
*/
var hasOperatorRegex = regexp.MustCompile(`[\+\-\*\/]`)

func Finder(text string) []FoundExpression {
	allIndexes := condidateRegex.FindAllStringIndex(text, -1) // -1 сняли лимит на количество поиска слов тоесть все выведет

	// Методы Find... и FindAll... возвращают nil, когда ни одного совпадения не найдено.
	if allIndexes == nil {
		return nil
	}

	results := make([]FoundExpression, 0, len(allIndexes))

	for _, indexes := range allIndexes {
		// операция получения подстроки (slicing) встроена в сам синтаксис языка.
		// Конструкция text[start:end] — это не вызов функции, это фундаментальная операция, такая же, как a + b.
		// Здесь как text.substring(start, end)
		// Эта конструкция работает не только со строками.
		// Она работает со всеми "нарезаемыми" (sliceable) типами в Go.
		//  [start:end] — это универсальный языковой механизм для создания "вида" (view)
		// на непрерывную последовательность данных.
		// Да, если ты изменишь элемент в исходном срезе, он изменится и в дочернем срезе, и наоборот.
		// состоит из Pointer,Length, Capacity.

		// Это фундаментальное свойство языка.
		// Вы не можете изменить символ в уже созданной строке.
		// Если вы хотите "изменить" строку, вы на самом деле создаете совершенно новую строку в памяти.
		condidate := text[indexes[0]:indexes[1]]

		if hasOperatorRegex.MatchString(condidate) {
			results = append(results, FoundExpression{
				condidate,
				indexes[0],
				indexes[1],
			})
		}
	}

	return results
}
