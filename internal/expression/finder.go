package expression

import (
	"regexp"
)

type FoundExpression struct {
	Expression string
	StartPos   int
	EndPos     int
}

/*
выносим regex из функции так как

regexp.MustCompile:
1) Парсит шаблон, проверяет его на синтаксические ошибки.
2) Строит из него конечный автомат — специальную структуру данных, оптимизированную для поиска.

Эта операция относительно "дорогая". Она занимает процессорное время.

Если вы вызовете Finder 1000 раз, то 1000 раз будет
выполняться эта "дорогая" операция компиляции одного и того же шаблона. Это бессмысленная трата ресурсов.

ХОРОШО: Компиляция происходит только ОДИН РАЗ, когда программа запускается.
var candidateRegex = ... — это объявление глобальной (на уровне пакета) переменной.
Этот код выполнится один раз при инициализации пакета.
Всегда выносите regexp.MustCompile в глобальные переменные (на уровне пакета),
если шаблон известен заранее и не меняется.

[0-9\(] - любая цифра или (
[\d\s\.\+\-\*\/\(\)]* - 0 или более раз символы числа, пробела, скобок, умножения и деления и тд
[0-9\)] - любая цифра или )
*/
var condidateRegex = regexp.MustCompile(`(?:(?:\-\s*)?[0-9\(])[\d\s\.\+\-\*\/()]*[0-9\)]`)

/*
прошлое выражение выцепляет не только выражения,
но и числа и здесь фильтруем, чтобы было выражение содержащие мат знаки
123 - не пройдет, 1 + 2 продет есть +
*/

// очищаем от 123 или -123 и прочему мусора
var hasOperatorRegex = regexp.MustCompile(`[\+\*\/\-]`)

// для дальнейшей проверки нужно чтобы если перед или после 1 оператора не идет число то отбрасываем

func Finder(text string) []FoundExpression {
	allIndexes := condidateRegex.FindAllStringIndex(text, -1) // -1 сняли лимит на количество поиска слов тоесть все выведет

	// Методы Find... и FindAll... возвращают nil, когда ни одного совпадения не найдено.
	if allIndexes == nil {
		return nil
	}

	results := make([]FoundExpression, 0, len(allIndexes))

	for _, indexes := range allIndexes {
		// операция получения подстроки (slicing) встроена в сам синтаксис языка.
		// Конструкция text[start:end] — это не вызов функции, это фундаментальная операция, такая же, как a + b.
		// Здесь как text.substring(start, end)
		// Эта конструкция работает не только со строками.
		// Она работает со всеми "нарезаемыми" (sliceable) типами в Go.
		//  [start:end] — это универсальный языковой механизм для создания "вида" (view)
		// на непрерывную последовательность данных.
		// Да, если ты изменишь элемент в исходном срезе, он изменится и в дочернем срезе, и наоборот.
		// состоит из Pointer,Length, Capacity.

		// Это фундаментальное свойство языка.
		// Вы не можете изменить символ в уже созданной строке.
		// Если вы хотите "изменить" строку, вы на самом деле создаете совершенно новую строку в памяти.
		condidate := text[indexes[0]:indexes[1]]
		//fmt.Printf("condidate: %s\n", condidate)

		// !!!!!!!!!!!!!!!!!!!!!!!!!!
		// ошибка метод indexes[0] и indexes[1] возвращают байтовую длину
		// для русских символов len(text) вернет 41 так как 1 сивол кодируется 2 байтами
		// а индекс обращение по байтам
		/*
			Ц = 2 байта
			е = 2 байта
			н = 2 байта
			а = 2 байта
			 = 1 байт
			р = 2 байта
			а = 2 байта
			в = 2 байта
			н = 2 байта
			а = 2 байта
			 = 1 байт
		*/
		// regexp работает с байтами. Все индексы, которые возвращает FindAllStringIndex — это байтовые смещения от начала строки, а не смещения в символах.
		// Операция s[i] обращается к i-тому байту. Если ты напишешь s := "Привет"; fmt.Println(string(s)), ты получишь не букву П, а "кракозябру", потому что ты вывел только первый из двух байт, которые составляют эту букву.
		// Движок regexp в Go, как и сама строка в Go, работает на уровне байт. Он не знает о "символах" или "буквах" в человеческом понимании. Он видит строку как последовательность байт.
		// символы (руны). Руны это и есть один символ русский или другой в нашем представлении, но в памяти 2 байта

		if hasOperatorRegex.MatchString(condidate) {
			results = append(results, FoundExpression{
				condidate,
				indexes[0],
				indexes[1],
			})
		}
	}

	/*
		фиксим баг с Ожидали [], но получили []

		results := make([]FoundExpression, 0) или results := []FoundExpression{}
		Что это в памяти: Заголовок среза, у которого указатель указывает на реально существующий,
		но пустой массив в памяти. Длина 0, емкость 0 (или больше, если указана). Это не "ничто", это "пустая коробка".
		reflect.DeepEqual(nil, make([]FoundExpression, 0)) вернет false!

		Возвращаем nil а не пустым срезом иначе DeepEqual скажет что они разные
		но по факту логики они равны пустые, поэтому вернем nil
	*/

	if len(results) == 0 {
		return nil
	}

	return results
}
